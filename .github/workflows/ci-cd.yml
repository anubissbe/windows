# Docker Extension CI/CD Pipeline
# For: Docker extensions and containerized applications
# Self-hosted runners: 192.168.1.16 with 20 available runners

name: ğŸ³ Docker Extension Pipeline

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main, develop ]
  release:
    types: [ published ]

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

env:
  DOCKER_REGISTRY: ghcr.io
  DOCKER_HUB_REGISTRY: docker.io
  IMAGE_NAME: ${{ github.repository }}

jobs:
  # ğŸ” Static Analysis & Security
  code-analysis:
    name: ğŸ” Code Analysis & Security
    runs-on: [self-hosted, linux, docker]
    timeout-minutes: 15
    steps:
      - name: ğŸ“¥ Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: ğŸ” Dockerfile linting
        uses: hadolint/hadolint-action@v3.1.0
        with:
          dockerfile: Dockerfile
          format: sarif
          output-file: hadolint-results.sarif
          no-fail: true

      - name: ğŸ“Š Upload Hadolint results
        uses: github/codeql-action/upload-sarif@v3
        if: always()
        with:
          sarif_file: hadolint-results.sarif

      - name: ğŸ”’ Run Trivy filesystem scan
        uses: aquasecurity/trivy-action@master
        with:
          scan-type: 'fs'
          scan-ref: '.'
          format: 'sarif'
          output: 'trivy-fs-results.sarif'

      - name: ğŸ“Š Upload Trivy filesystem results
        uses: github/codeql-action/upload-sarif@v3
        if: always()
        with:
          sarif_file: 'trivy-fs-results.sarif'

      - name: ğŸ” Shell script analysis
        run: |
          if find . -name "*.sh" -type f | head -1 | grep -q .; then
            docker run --rm -v "$PWD:/mnt" koalaman/shellcheck:stable $(find . -name "*.sh" -type f)
          else
            echo "No shell scripts found"
          fi

  # ğŸ—ï¸ Multi-Platform Build
  build:
    name: ğŸ—ï¸ Multi-Platform Build
    runs-on: [self-hosted, linux, docker]
    timeout-minutes: 30
    strategy:
      matrix:
        platform: [linux/amd64, linux/arm64]
    steps:
      - name: ğŸ“¥ Checkout code
        uses: actions/checkout@v4

      - name: ğŸ³ Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: ğŸ—ï¸ Build Docker image for ${{ matrix.platform }}
        uses: docker/build-push-action@v5
        with:
          context: .
          platforms: ${{ matrix.platform }}
          push: false
          tags: ${{ env.IMAGE_NAME }}:test-${{ matrix.platform }}
          cache-from: type=gha,scope=${{ matrix.platform }}
          cache-to: type=gha,mode=max,scope=${{ matrix.platform }}
          outputs: type=docker,dest=/tmp/image-${{ matrix.platform }}.tar

      - name: ğŸ“¦ Upload build artifact
        uses: actions/upload-artifact@v4
        with:
          name: docker-image-${{ matrix.platform }}
          path: /tmp/image-${{ matrix.platform }}.tar
          retention-days: 1

  # ğŸ§ª Container Testing
  container-tests:
    name: ğŸ§ª Container Tests
    runs-on: [self-hosted, linux, docker]
    timeout-minutes: 20
    needs: [build]
    strategy:
      matrix:
        platform: [linux/amd64, linux/arm64]
    steps:
      - name: ğŸ“¥ Checkout code
        uses: actions/checkout@v4

      - name: ğŸ“¦ Download build artifact
        uses: actions/download-artifact@v4
        with:
          name: docker-image-${{ matrix.platform }}
          path: /tmp

      - name: ğŸ³ Load Docker image
        run: docker load --input /tmp/image-${{ matrix.platform }}.tar

      - name: ğŸ§ª Test container startup
        run: |
          CONTAINER_ID=$(docker run -d ${{ env.IMAGE_NAME }}:test-${{ matrix.platform }})
          sleep 10
          
          # Check if container is still running
          if docker ps | grep -q $CONTAINER_ID; then
            echo "âœ… Container started successfully"
          else
            echo "âŒ Container failed to start"
            docker logs $CONTAINER_ID
            exit 1
          fi
          
          docker stop $CONTAINER_ID
          docker rm $CONTAINER_ID

      - name: ğŸ” Container health check
        run: |
          if docker run --rm ${{ env.IMAGE_NAME }}:test-${{ matrix.platform }} --version; then
            echo "âœ… Health check passed"
          else
            echo "âš ï¸ No health check available"
          fi

      - name: ğŸ“Š Container size analysis
        run: |
          SIZE=$(docker images ${{ env.IMAGE_NAME }}:test-${{ matrix.platform }} --format "table {{.Size}}" | tail -n 1)
          echo "ğŸ“¦ Image size for ${{ matrix.platform }}: $SIZE"

  # ğŸ”’ Security Scanning
  security-scan:
    name: ğŸ”’ Container Security Scan
    runs-on: [self-hosted, linux, docker]
    timeout-minutes: 15
    needs: [build]
    steps:
      - name: ğŸ“¥ Checkout code
        uses: actions/checkout@v4

      - name: ğŸ“¦ Download build artifact (amd64)
        uses: actions/download-artifact@v4
        with:
          name: docker-image-linux/amd64
          path: /tmp

      - name: ğŸ³ Load Docker image
        run: docker load --input /tmp/image-linux/amd64.tar

      - name: ğŸ”’ Run Trivy container scan
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: ${{ env.IMAGE_NAME }}:test-linux/amd64
          format: 'sarif'
          output: 'trivy-container-results.sarif'

      - name: ğŸ“Š Upload container security results
        uses: github/codeql-action/upload-sarif@v3
        if: always()
        with:
          sarif_file: 'trivy-container-results.sarif'

      - name: ğŸ” Container vulnerability summary
        run: |
          docker run --rm -v /var/run/docker.sock:/var/run/docker.sock \
            -v $PWD:/tmp aquasec/trivy:latest image \
            --format table --exit-code 0 \
            ${{ env.IMAGE_NAME }}:test-linux/amd64

  # ğŸ¯ Extension-Specific Tests
  extension-tests:
    name: ğŸ¯ Docker Extension Tests
    runs-on: [self-hosted, linux, docker]
    timeout-minutes: 25
    needs: [container-tests]
    if: contains(github.repository, 'extension') || contains(github.repository, 'docker')
    steps:
      - name: ğŸ“¥ Checkout code
        uses: actions/checkout@v4

      - name: ğŸ“¦ Download build artifact (amd64)
        uses: actions/download-artifact@v4
        with:
          name: docker-image-linux/amd64
          path: /tmp

      - name: ğŸ³ Load Docker image
        run: docker load --input /tmp/image-linux/amd64.tar

      - name: ğŸ”§ Install Docker extension CLI
        run: |
          # Install docker extension CLI if available
          curl -fsSL https://raw.githubusercontent.com/docker/extensions-sdk/main/scripts/install-extension-cli.sh | sh
          
      - name: ğŸ“‹ Validate extension metadata
        run: |
          if [ -f "metadata.json" ]; then
            echo "âœ… Extension metadata found"
            cat metadata.json | jq .
          else
            echo "âš ï¸ No extension metadata found"
          fi

      - name: ğŸ§ª Test extension installation
        run: |
          if command -v docker-extension >/dev/null 2>&1; then
            docker-extension validate ${{ env.IMAGE_NAME }}:test-linux/amd64
          else
            echo "âš ï¸ Docker extension CLI not available"
          fi

      - name: ğŸ¯ Test extension functionality
        run: |
          # Test extension-specific functionality
          if [ -f "test-extension.sh" ]; then
            chmod +x test-extension.sh
            ./test-extension.sh ${{ env.IMAGE_NAME }}:test-linux/amd64
          else
            echo "âš ï¸ No extension test script found"
          fi

  # ğŸ“Š Performance & Resource Usage
  performance:
    name: ğŸ“Š Performance Tests
    runs-on: [self-hosted, linux, docker]
    timeout-minutes: 20
    needs: [container-tests]
    steps:
      - name: ğŸ“¥ Checkout code
        uses: actions/checkout@v4

      - name: ğŸ“¦ Download build artifact (amd64)
        uses: actions/download-artifact@v4
        with:
          name: docker-image-linux/amd64
          path: /tmp

      - name: ğŸ³ Load Docker image
        run: docker load --input /tmp/image-linux/amd64.tar

      - name: ğŸ“Š Resource usage test
        run: |
          echo "ğŸ§ª Testing resource usage..."
          
          # Start container with resource limits
          CONTAINER_ID=$(docker run -d --memory=512m --cpus=1.0 \
            ${{ env.IMAGE_NAME }}:test-linux/amd64)
          
          sleep 10
          
          # Get resource usage
          docker stats --no-stream --format "table {{.Container}}\t{{.CPUPerc}}\t{{.MemUsage}}" $CONTAINER_ID
          
          # Check memory usage doesn't exceed 80% of limit
          MEM_USAGE=$(docker stats --no-stream --format "{{.MemPerc}}" $CONTAINER_ID | sed 's/%//')
          if (( $(echo "$MEM_USAGE > 80" | bc -l) )); then
            echo "âš ï¸ High memory usage: ${MEM_USAGE}%"
          else
            echo "âœ… Memory usage within limits: ${MEM_USAGE}%"
          fi
          
          docker stop $CONTAINER_ID
          docker rm $CONTAINER_ID

      - name: âš¡ Startup time test
        run: |
          echo "ğŸ§ª Testing startup time..."
          
          START_TIME=$(date +%s.%N)
          CONTAINER_ID=$(docker run -d ${{ env.IMAGE_NAME }}:test-linux/amd64)
          
          # Wait for container to be ready (adjust based on your app)
          timeout 30s sh -c 'until docker logs '$CONTAINER_ID' 2>&1 | grep -q "ready\|started\|listening"; do sleep 1; done' || true
          
          END_TIME=$(date +%s.%N)
          STARTUP_TIME=$(echo "$END_TIME - $START_TIME" | bc)
          
          echo "âš¡ Startup time: ${STARTUP_TIME} seconds"
          
          docker stop $CONTAINER_ID
          docker rm $CONTAINER_ID

  # ğŸ“¦ Multi-Registry Release
  release:
    name: ğŸ“¦ Multi-Registry Release
    runs-on: [self-hosted, linux, docker]
    timeout-minutes: 30
    needs: [code-analysis, container-tests, security-scan]
    if: github.event_name == 'release' && github.event.action == 'published'
    permissions:
      contents: write
      packages: write
    steps:
      - name: ğŸ“¥ Checkout code
        uses: actions/checkout@v4

      - name: ğŸ³ Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: ğŸ” Login to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.DOCKER_REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: ğŸ” Login to Docker Hub
        uses: docker/login-action@v3
        with:
          registry: ${{ env.DOCKER_HUB_REGISTRY }}
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: ğŸ·ï¸ Extract metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: |
            ${{ env.DOCKER_REGISTRY }}/${{ env.IMAGE_NAME }}
            ${{ env.DOCKER_HUB_REGISTRY }}/${{ env.IMAGE_NAME }}
          tags: |
            type=ref,event=branch
            type=ref,event=pr
            type=semver,pattern={{version}}
            type=semver,pattern={{major}}.{{minor}}
            type=semver,pattern={{major}}
            type=raw,value=latest,enable={{is_default_branch}}

      - name: ğŸš¢ Build and push to multiple registries
        uses: docker/build-push-action@v5
        with:
          context: .
          platforms: linux/amd64,linux/arm64
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: ğŸ“‹ Generate image manifest
        run: |
          echo "## ğŸ³ Docker Images" > release-notes.md
          echo "" >> release-notes.md
          echo "### GitHub Container Registry" >> release-notes.md
          echo '```bash' >> release-notes.md
          echo "docker pull ${{ env.DOCKER_REGISTRY }}/${{ env.IMAGE_NAME }}:${{ github.event.release.tag_name }}" >> release-notes.md
          echo '```' >> release-notes.md
          echo "" >> release-notes.md
          echo "### Docker Hub" >> release-notes.md
          echo '```bash' >> release-notes.md
          echo "docker pull ${{ env.DOCKER_HUB_REGISTRY }}/${{ env.IMAGE_NAME }}:${{ github.event.release.tag_name }}" >> release-notes.md
          echo '```' >> release-notes.md
          echo "" >> release-notes.md
          echo "### Supported Architectures" >> release-notes.md
          echo "- linux/amd64" >> release-notes.md
          echo "- linux/arm64" >> release-notes.md

      - name: ğŸ” Generate vulnerability report
        run: |
          echo "" >> release-notes.md
          echo "### Security Scan Results" >> release-notes.md
          docker run --rm -v /var/run/docker.sock:/var/run/docker.sock \
            -v $PWD:/tmp aquasec/trivy:latest image \
            --format markdown \
            ${{ env.DOCKER_REGISTRY }}/${{ env.IMAGE_NAME }}:${{ github.event.release.tag_name }} >> release-notes.md

      - name: ğŸ“„ Update release notes
        uses: softprops/action-gh-release@v1
        with:
          body_path: release-notes.md
          files: |
            Dockerfile
            metadata.json

  # ğŸ”„ Scheduled Image Updates
  scheduled-build:
    name: ğŸ”„ Scheduled Security Updates
    runs-on: [self-hosted, linux, docker]
    timeout-minutes: 20
    if: github.event_name == 'schedule'
    steps:
      - name: ğŸ“¥ Checkout code
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: ğŸ³ Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: ğŸ—ï¸ Build with latest base images
        uses: docker/build-push-action@v5
        with:
          context: .
          platforms: linux/amd64,linux/arm64
          push: false
          tags: ${{ env.IMAGE_NAME }}:security-update
          cache-from: type=gha
          cache-to: type=gha,mode=max
          no-cache: true  # Force fresh build with latest base images

      - name: ğŸ”’ Security scan of updated image
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: ${{ env.IMAGE_NAME }}:security-update
          format: 'json'
          output: 'security-scan.json'

      - name: ğŸ“Š Compare security posture
        run: |
          # Check if there are security improvements
          VULNERABILITIES=$(jq '.Results[0].Vulnerabilities | length' security-scan.json 2>/dev/null || echo "0")
          echo "Current vulnerabilities: $VULNERABILITIES"
          
          if [ "$VULNERABILITIES" -lt "$(cat last-vulnerability-count.txt 2>/dev/null || echo 999)" ]; then
            echo "Security improvements found, creating PR"
            echo "$VULNERABILITIES" > last-vulnerability-count.txt
          fi

      - name: ğŸ“ Create security update PR
        uses: peter-evans/create-pull-request@v5
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          commit-message: 'ğŸ”’ chore: security updates for base images'
          title: 'ğŸ”’ Automated security updates'
          body: |
            ## ğŸ”’ Automated Security Updates
            
            This PR updates base images to include the latest security patches.
            
            - Rebuilt with latest base images
            - Security scan results included
            
            **Note**: Please review and test before merging.
          branch: chore/security-updates
          delete-branch: true

# ğŸ“Š Workflow Status Badge
# Add to README.md:
# [![Docker Extension Pipeline](https://github.com/YOUR_USERNAME/YOUR_REPO/workflows/ğŸ³%20Docker%20Extension%20Pipeline/badge.svg)](https://github.com/YOUR_USERNAME/YOUR_REPO/actions)